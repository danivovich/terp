* Terp

   =terp= is a toy language that falls somewhere between an ML and a lisp.

   Currently implemented:
     + integers
     + strings
     + atoms
     + basic arithmetic (=+=, =-=, =*=, =/=)
     + booleans (=#t=, =#f=)
     + conditionals
       + =if then else=
       + =cond=
     + Lambda functions (=lambda=)
     + variable binding (=let=)
     + recursive functions (=letrec=)
     + module imports
     + HM type inference

   Additional examples can be found in the [[https://github.com/tpoulsen/terp/tree/master/examples][examples]] directory.
* Usage
** Comments
   Comments are single-line and begin with =;;=:
   #+BEGIN_SRC racket
     ;; A comment
     (+ 5 1)
   #+END_SRC

** Variable binding
   Variables are bound using =let=:
    #+BEGIN_SRC racket
      (let :x 5)

      (let :identity (lambda (:x) :x))

      (:identity :x)
      ;; 5
    #+END_SRC
** Conditionals
   =if= expressions must include a value for both the true and false case (an =if= and an =else=).
   #+BEGIN_SRC racket
     (if #t 5 10)
     ;; 5

     (let x 5)
     (if (equal? x 5) (* x x) 0)
     ;; 25
   #+END_SRC

   =cond= can be used to test multiple possible conditions without chaining if/elses:
   =cond= takes conditions and their outcomes should their case be true; the last condition should be a default.
   #+BEGIN_SRC racket
     (let sound
         (lambda (animal)
           (cond
            [(equal? animal "cow") "moo"]
            [(equal? animal "cat") "meow"]
            [(equal? animal "dog") "bark"]
            [#t "zzz"]
            )))

     (sound "dog")
     ;; "bark"
   #+END_SRC
** Function definition
   Functions are defined using =lambda=; they can be bound to a name with =let=.

   The arguments must be wrapped in parens. The body of the function can be bare if it does not have to be evaluated (e.g. returns a single value). Otherwise, the body must be parenthesized as well.
   #+BEGIN_SRC racket
     ;; An anonymous identity function.
     ;; It returns the value it receives.
     (lambda (x) x)

     ;; Defining a named function:
     (let double
         (x) (* x x))

     (double 5)
     ;; 10
   #+END_SRC

   Multi-argument functions:
   #+BEGIN_SRC racket
     (((lambda (:x)
         (lambda (:y)
           (+ :x :y))) 5 ) 3)
     ;; 8

     ((lambda (:x :y)
        (+ :x :y)) 5 3)
     ;; 8
   #+END_SRC

   Functions are automatically [[https://en.wikipedia.org/wiki/Currying][curried]] when defined. This allows for easy partial application of multi-argument functions:
   #+BEGIN_SRC racket
     ;; add is a function that takes two arguments.
     ;;   Currying turns it into a series of functions
     ;;   that each takes a single argument.
     (let add
         (lambda (x y) (+ x y)))

     ;; We can define a new function, add_five, that partially
     ;; applies add to the value 5:
     (let add_five
         (add 5))

     ;; evaluating add_five with 3 binds the last argument in
     ;; add, and the function is fully evaluated:
     (add_five 3)
     ;; 8
   #+END_SRC

   Functions can also be defined using =defn=; this is syntactic sugar for =let/lambda= definition:
   #+BEGIN_SRC racket
     (defn add (x y) (+ x y))
   #+END_SRC
** Recursive functions
   Recursive functions are defined with =letrec=.
   The base case(s) and recursive case(s) must be provided or the function will not terminate.
    #+BEGIN_SRC racket
      (letrec factorial
        (lambda (n)
          (if (equal? n 0)
              1
              (* n (factorial (- n 1))))))

      (factorial 5)
      ;; 120
    #+END_SRC

    Recursive functions can also be defined using =defrec=; this is syntactic sugar for =letrec/lambda=:
    #+BEGIN_SRC racket
      (defrec factorial (n)
          (if (equal? n 0)
              1
              (* n (factorial (- n 1)))))

      (factorial 5)
      ;; 120
    #+END_SRC
** Module system
   Modules can be imported in to other modules to make their functions/defined expressions available.
   Modules must specify the functions that they export or they cannot be used in other modules.

   Syntax is =(require ...)=, where =...= is a sequence of relative filepaths to the imported module.
   #+BEGIN_SRC racket
     (require "examples/factorial.tp"
              "examples/identity.tp")

     (factorial (:identity 10))
   #+END_SRC
   
   With [[https://github.com/tpoulsen/terp/blob/master/examples/factorial.tp]["examples/factorial.tp"]] and [[https://github.com/tpoulsen/terp/blob/master/examples/identity.tp]["examples/identity.tp"]] defined as in the examples directory.

   To use functions from an imported module, the module that is imported must explicitly export functions it wants to make available externally.
   The syntax is =(provide ...)= where =...= is a sequence of function names.
   #+BEGIN_SRC racket
     ;; Module only exports factorial; identity is private.

     (provide factorial)

     (letrec factorial
       (lambda (n)
         (if (equal? n 0)
             1
             (* n (factorial (- n 1))))))

     (let identity
         (lambda (x) x))
   #+END_SRC
** Type system
   Terp implements Hindley-Milner type inference. Currently, type checking is performed only on code run in the REPL; this is a work in progress and will change in the future.

   Expressions in the REPL are type checked prior to evaluation. If an expression fails the type check, it won't be evaluated.
   To see the inferred type for an expressions, prefix it with =:t= or =:type=. 

   The REPL maintains a type environment that includes functions and variables defined with =let= or =letrec=:

   /Binding a simple variable:/

   [[file:media/repl_simple_env.gif]]
   
   /Binding and using a recursive, higher-order function:/
   [[file:media/repl_type_env.png]]
** Pattern matching
   #+BEGIN_SRC racket
     (data (Maybe a) [Just a] [Nothing])

     (type maybePlusFive (-> [Just Int] [Just Int]))
     (defn maybePlusFive
       (x)
       (match (x)
               [(Just y) (Just (+ 5 y))]
               [(Nothing) (Nothing)]))

     (maybePlusFive (Just 5))
     ;; Just 10
     (maybePlusFive (Nothing))
     ;; Nothing
   #+END_SRC
** Evaluating a file:
   There's a mix task (=mix terp.run $FILENAME=) to evaluate a file:

   Filename =test.tp= (=terp= files must end in =.tp=):
   #+BEGIN_SRC racket
     (let :identity
         (lambda '(:x) :x))

     (let :double_identity
         ((:identity :identity) 5))

     (+ 2 :double_identity)
   #+END_SRC

   #+BEGIN_SRC sh
     $ mix terp.run test.tp
     7
   #+END_SRC
   * With =@debug= set to =true=, the results of the file evaluation are printed to stdout.
** REPL
   There's a basic repl using the mix task =mix terp.repl=.

   Currently allows expression evaluation (including module imports). History/scrollback not currently implemented.
   [[file:media/repl_demo.gif]] 

   As a workaround for history/scrollback in the repl, start it as =iex -S mix terp.repl=. The IEx shell provides those features while still running the terp repl.
** Error Messages
   To help with debugging, error messages try to be as informative as possible:
   [[file:media/error_messages.png]]
