* Terp

   =terp= is an interpreter for a toy, lisp-like language.

   Currently implemented:
     + integers
     + strings
     + basic arithmetic (=+=, =-=, =*=, =/=)
     + booleans (=#t=, =#f=)
     + conditionals
       + =if then els=
       + =cond=
     + Lambda functions (=lambda=)
     + variable binding (=let=)
     + recursive functions (=letrec=)

   Additional examples can be found in the [[https://github.com/tpoulsen/terp/tree/master/examples][examples]] directory.

** Usage
   #+BEGIN_SRC elixir
     iex> "(+ 5 3)"
     ...> |> Terp.eval()
     8

     iex> "(* 2 4 5)"
     ...> |> Terp.eval()
     40

     iex> "(* 2 4 (+ 4 1))"
     ...> |> Terp.eval()
     40

     iex> "(if #t (* 5 5) (+ 4 1))"
     ...> |> Terp.eval()
     25

     iex> "(if #f (* 5 5) (+ 4 1))"
     ...> |> Terp.eval()
     5

     iex> "((lambda (:x) :x) 5)"
     ...> |> Terp.eval
     5

     iex> "(((lambda (:x) (lambda '(:y) (+ :x :y))) 5 ) 3)"
     ...> |> Terp.eval
     8

     iex> "((lambda (:x :y) (+ :x :y)) 5 3)"
     ...> |> Terp.eval
     8
   #+END_SRC

** Comments
   Comments are single-line and begin with `;;`:
   #+BEGIN_SRC scheme
     ;; A comment
     (+ 5 1)
   #+END_SRC

** Variable binding
   Variables are bound using =let=:
    #+BEGIN_SRC scheme
      (let :x 5)

      (let :identity (lambda (:x) :x))

      (:identity :x)
      ;; 5
    #+END_SRC
** Conditionals
   =if= expressions must include a value for both the true and false case (an =if= and an =else=).
   #+BEGIN_SRC scheme
     (if #t 5 10)
     ;; 5

     (let x 5)
     (if (equal? x 5) (* x x) 0)
     ;; 25
   #+END_SRC

   =cond= can be used to test multiple possible conditions without chaining if/elses:
   =cond= takes conditions and their outcomes should their case be true; the last condition should be a default.:w
   #+BEGIN_SRC scheme
     (let sound
         (lambda (animal)
           (cond
            [(equal? animal "cow") "moo"]
            [(equal? animal "cat") "meow"]
            [(equal? animal "dog") "bark"]
            [#t "zzz"]
            )))

     (sound "dog")
     ;; "bark"
   #+END_SRC
** Function definition
   Functions are defined using =lambda=; they can be bound to a name with =let=.

   The arguments must be wrapped in parens. The body of the function can be bare if it does not have to be evaluated (e.g. returns a single value). Otherwise, the body must be parenthesized as well.
   #+BEGIN_SRC scheme
     ;; An anonymous identity function.
     ;; It returns the value it receives.
     (lambda (x) x)

     ;; Defining a named function:
     (let double
         (x) (* x x))

     (double 5)
     ;; 10
   #+END_SRC
** Recursive functions
   Recursive functions are defined with =letrec=:
    #+BEGIN_SRC scheme
      (letrec :factorial
        (lambda (:n)
          (if (:eq :n 0)
              1
              (* :n (:factorial (- :n 1))))))

      (:factorial 5)
      ;; 120
    #+END_SRC

** Evaluating a file:
   There's a mix task (=mix terp.run $FILENAME=) to evaluate a file:

   Filename =test.tp= (=terp= files must end in =.tp=):
   #+BEGIN_SRC scheme
     (let :identity
         (lambda '(:x) :x))

     (let :double_identity
         ((:identity :identity) 5))

     (+ 2 :double_identity)
   #+END_SRC

   #+BEGIN_SRC sh
     $ mix terp.run test.tp
     7
   #+END_SRC
   * With =@debug= set to =true=, the results of the file evaluation are printed to stdout.
