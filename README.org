* Terp

   =terp= is an interpreter for a toy, lisp-like language.

   Currently implemented:
     + integers
     + basic arithmetic (=+=, =-=, =*=, =/=)
     + booleans (=#t=, =#f=)
     + =if then else= conditionals
     + Lambda functions (=lambda=)
     + variable binding (=let=)

** Usage
   #+BEGIN_SRC elixir
     iex> "(+ 5 3)"
     ...> |> Terp.eval()
     8

     iex> "(* 2 4 5)"
     ...> |> Terp.eval()
     40

     iex> "(* 2 4 (+ 4 1))"
     ...> |> Terp.eval()
     40

     iex> "(if #t (* 5 5) (+ 4 1))"
     ...> |> Terp.eval()
     25

     iex> "(if #f (* 5 5) (+ 4 1))"
     ...> |> Terp.eval()
     5

     iex> "((lambda (:x) :x) 5)"
     ...> |> Terp.eval
     5

     iex> "(((lambda '(:x) (lambda '(:y) (+ :x :y))) 5 ) 3)"
     ...> |> Terp.eval
     8

     iex> "((lambda '(:x :y) (+ :x :y)) 5 3)"
     ...> |> Terp.eval
     8
   #+END_SRC

** Comments
   Comments are single-line and begin with `;;`:
   #+BEGIN_SRC scheme
     ;; A comment
     (+ 5 1)
   #+END_SRC

** Variable binding
   Variables are bound using =let=:
    #+BEGIN_SRC scheme
      (let :x 5)

      (let :identity (lambda '(:x) :x))

      (:identity :x)
      ;; 5
    #+END_SRC

** Evaluating a file:
   There's a mix task (=mix terp.run $FILENAME=) to evaluate a file:

   Filename =test.tp= (=terp= files must end in =.tp=):
   #+BEGIN_SRC scheme
     (let :identity (lambda '(:x) :x))
     (let :double_identity ((:identity :identity) 5))

     (+ 2 :double_identity)
   #+END_SRC

   #+BEGIN_SRC sh
     $ mix terp.run test.tp
     7
   #+END_SRC
   * With =@debug= set to =true=, the results of the file evaluation are printed to stdout.
