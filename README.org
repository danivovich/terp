* Terp

   =terp= is an interpreter for a toy, lisp-like language.

   Currently implemented:
     + integers
     + strings
     + basic arithmetic (=+=, =-=, =*=, =/=)
     + booleans (=#t=, =#f=)
     + conditionals
       + =if then else=
       + =cond=
     + Lambda functions (=lambda=)
     + variable binding (=let=)
     + recursive functions (=letrec=)

   Additional examples can be found in the [[https://github.com/tpoulsen/terp/tree/master/examples][examples]] directory.
* Usage
** Comments
   Comments are single-line and begin with `;;`:
   #+BEGIN_SRC scheme
     ;; A comment
     (+ 5 1)
   #+END_SRC

** Variable binding
   Variables are bound using =let=:
    #+BEGIN_SRC scheme
      (let :x 5)

      (let :identity (lambda (:x) :x))

      (:identity :x)
      ;; 5
    #+END_SRC
** Conditionals
   =if= expressions must include a value for both the true and false case (an =if= and an =else=).
   #+BEGIN_SRC scheme
     (if #t 5 10)
     ;; 5

     (let x 5)
     (if (equal? x 5) (* x x) 0)
     ;; 25
   #+END_SRC

   =cond= can be used to test multiple possible conditions without chaining if/elses:
   =cond= takes conditions and their outcomes should their case be true; the last condition should be a default.
   #+BEGIN_SRC scheme
     (let sound
         (lambda (animal)
           (cond
            [(equal? animal "cow") "moo"]
            [(equal? animal "cat") "meow"]
            [(equal? animal "dog") "bark"]
            [#t "zzz"]
            )))

     (sound "dog")
     ;; "bark"
   #+END_SRC
** Function definition
   Functions are defined using =lambda=; they can be bound to a name with =let=.

   The arguments must be wrapped in parens. The body of the function can be bare if it does not have to be evaluated (e.g. returns a single value). Otherwise, the body must be parenthesized as well.
   #+BEGIN_SRC scheme
     ;; An anonymous identity function.
     ;; It returns the value it receives.
     (lambda (x) x)

     ;; Defining a named function:
     (let double
         (x) (* x x))

     (double 5)
     ;; 10
   #+END_SRC

   Multi-argument functions:
   #+BEGIN_SRC scheme
     (((lambda (:x)
         (lambda (:y)
           (+ :x :y))) 5 ) 3)
     ;; 8

     ((lambda (:x :y)
        (+ :x :y)) 5 3)
     ;; 8
   #+END_SRC

   Functions are automatically [[https://en.wikipedia.org/wiki/Currying][curried]] when defined. This allows for easy partial application of multi-argument functions:
   #+BEGIN_SRC scheme
     ;; add is a function that takes two arguments.
     ;;   Currying turns it into a series of functions
     ;;   that each takes a single argument.
     (let add
         (lambda (x y) (+ x y)))

     ;; We can define a new function, add_five, that partially
     ;; applies add to the value 5:
     (let add_five
         (add 5))

     ;; evaluating add_five with 3 binds the last argument in
     ;; add, and the function is fully evaluated:
     (add_five 3)
     ;; 8
   #+END_SRC
** Recursive functions
   Recursive functions are defined with =letrec=.
   The base case(s) and recursive case(s) must be provided or the function will not terminate.
    #+BEGIN_SRC scheme
      (letrec :factorial
        (lambda (:n)
          (if (:eq :n 0)
              1
              (* :n (:factorial (- :n 1))))))

      (:factorial 5)
      ;; 120
    #+END_SRC

** Evaluating a file:
   There's a mix task (=mix terp.run $FILENAME=) to evaluate a file:

   Filename =test.tp= (=terp= files must end in =.tp=):
   #+BEGIN_SRC scheme
     (let :identity
         (lambda '(:x) :x))

     (let :double_identity
         ((:identity :identity) 5))

     (+ 2 :double_identity)
   #+END_SRC

   #+BEGIN_SRC sh
     $ mix terp.run test.tp
     7
   #+END_SRC
   * With =@debug= set to =true=, the results of the file evaluation are printed to stdout.
