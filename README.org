* Terp

   =terp= is an interpreter for a toy, lisp-like language.

   Currently implemented:
     + integers
     + strings
     + atoms
     + basic arithmetic (=+=, =-=, =*=, =/=)
     + booleans (=#t=, =#f=)
     + conditionals
       + =if then else=
       + =cond=
     + Lambda functions (=lambda=)
     + variable binding (=let=)
     + recursive functions (=letrec=)
     + module imports

   Additional examples can be found in the [[https://github.com/tpoulsen/terp/tree/master/examples][examples]] directory.
* Usage
** Comments
   Comments are single-line and begin with =;;=:
   #+BEGIN_SRC racket
     ;; A comment
     (+ 5 1)
   #+END_SRC

** Variable binding
   Variables are bound using =let=:
    #+BEGIN_SRC racket
      (let :x 5)

      (let :identity (lambda (:x) :x))

      (:identity :x)
      ;; 5
    #+END_SRC
** Conditionals
   =if= expressions must include a value for both the true and false case (an =if= and an =else=).
   #+BEGIN_SRC racket
     (if #t 5 10)
     ;; 5

     (let x 5)
     (if (equal? x 5) (* x x) 0)
     ;; 25
   #+END_SRC

   =cond= can be used to test multiple possible conditions without chaining if/elses:
   =cond= takes conditions and their outcomes should their case be true; the last condition should be a default.
   #+BEGIN_SRC racket
     (let sound
         (lambda (animal)
           (cond
            [(equal? animal "cow") "moo"]
            [(equal? animal "cat") "meow"]
            [(equal? animal "dog") "bark"]
            [#t "zzz"]
            )))

     (sound "dog")
     ;; "bark"
   #+END_SRC
** Function definition
   Functions are defined using =lambda=; they can be bound to a name with =let=.

   The arguments must be wrapped in parens. The body of the function can be bare if it does not have to be evaluated (e.g. returns a single value). Otherwise, the body must be parenthesized as well.
   #+BEGIN_SRC racket
     ;; An anonymous identity function.
     ;; It returns the value it receives.
     (lambda (x) x)

     ;; Defining a named function:
     (let double
         (x) (* x x))

     (double 5)
     ;; 10
   #+END_SRC

   Multi-argument functions:
   #+BEGIN_SRC racket
     (((lambda (:x)
         (lambda (:y)
           (+ :x :y))) 5 ) 3)
     ;; 8

     ((lambda (:x :y)
        (+ :x :y)) 5 3)
     ;; 8
   #+END_SRC

   Functions are automatically [[https://en.wikipedia.org/wiki/Currying][curried]] when defined. This allows for easy partial application of multi-argument functions:
   #+BEGIN_SRC racket
     ;; add is a function that takes two arguments.
     ;;   Currying turns it into a series of functions
     ;;   that each takes a single argument.
     (let add
         (lambda (x y) (+ x y)))

     ;; We can define a new function, add_five, that partially
     ;; applies add to the value 5:
     (let add_five
         (add 5))

     ;; evaluating add_five with 3 binds the last argument in
     ;; add, and the function is fully evaluated:
     (add_five 3)
     ;; 8
   #+END_SRC
** Recursive functions
   Recursive functions are defined with =letrec=.
   The base case(s) and recursive case(s) must be provided or the function will not terminate.
    #+BEGIN_SRC racket
      (letrec :factorial
        (lambda (:n)
          (if (:eq :n 0)
              1
              (* :n (:factorial (- :n 1))))))

      (:factorial 5)
      ;; 120
    #+END_SRC
** Module system
   Modules can be imported in to other modules to make their functions/defined expressions available.
   Modules must specify the functions that they export or they cannot be used in other modules.

   Syntax is =(require ...)=, where =...= is a sequence of relative filepaths to the imported module.
   #+BEGIN_SRC racket
     (require "examples/factorial.tp"
              "examples/identity.tp")

     (factorial (:identity 10))
   #+END_SRC
   
   With [[https://github.com/tpoulsen/terp/blob/master/examples/factorial.tp]["examples/factorial.tp"]] and [[https://github.com/tpoulsen/terp/blob/master/examples/identity.tp]["examples/identity.tp"]] defined as in the examples directory.

   To use functions from an imported module, the module that is imported must explicitly export functions it wants to make available externally.
   The syntax is =(provide ...)= where =...= is a sequence of function names.
   #+BEGIN_SRC racket
     ;; Module only exports factorial; identity is private.

     (provide factorial)

     (letrec factorial
       (lambda (n)
         (if (equal? n 0)
             1
             (* n (factorial (- n 1))))))

     (let identity
         (lambda (x) x))
   #+END_SRC
** Evaluating a file:
   There's a mix task (=mix terp.run $FILENAME=) to evaluate a file:

   Filename =test.tp= (=terp= files must end in =.tp=):
   #+BEGIN_SRC racket
     (let :identity
         (lambda '(:x) :x))

     (let :double_identity
         ((:identity :identity) 5))

     (+ 2 :double_identity)
   #+END_SRC

   #+BEGIN_SRC sh
     $ mix terp.run test.tp
     7
   #+END_SRC
   * With =@debug= set to =true=, the results of the file evaluation are printed to stdout.
** REPL
   There's a basic repl using the mix task =mix terp.repl=.

   Functionality is currently fairly limited.
