#+TODO: TODO(t) INPROGRESS(i!) | DONE(d@/!) ICEBOX(x@)

* TODOs
** INPROGRESS [#A] prelude
   - State "INPROGRESS" from "TODO"       [2017-08-04 Fri 10:22]
   Standard library [0/2]
   - [ ] Add new functions [0/2]
     - [ ] map, filter, fold, etc...
     - [ ] length, etc...
   - [ ] Rewrite some of the built-in functions that are currently in elixir in terp.
** INPROGRESS [#A] clean up parser and terp implementations
   - State "INPROGRESS" from "TODO"       [2017-08-06 Sun 13:32]
   There's duplication and stuff that can likely be removed now that more functionality is built out.
   Would like to redo some of the early parsers in the style of more recent ones, e.g. tagging the value.
*** Checklist [3/5]:
   + [X] Clean up parsers
   + [X] Pull out condition bodies from the big case in terp.eval_trees
   + [X] Improve documentation
   + [ ] Rename some poorly named functions
   + [ ] Add typespecs
** TODO [#B] improve error handling
   Propagate error messages instead of ending in crashes
** TODO Remove circular dependencies
   Many of the functions that were split out of the eval function still reference it to evaluate their internals.
** TODO [#B] variable/defined function hoisting
** TODO Separate terp data structures from elixir data structures
   Particularly noticeable in the return of =cdr=; should be returning a terp list instead of an elixir list.
** TODO [#B] pattern matching
   =pmatch= or equivalent, a list of possible cases and evaluate the first that's true
    <2017-08-03 Thu> - Added =cond= for multi-possibility conditionals. Pattern matching still to come.
** DONE [#C] repl
   CLOSED: [2017-08-09 Wed 21:08]
   - State "DONE"       from "INPROGRESS" [2017-08-09 Wed 21:08] \\
     Initial implementation merged today. Doesn't have scrollback, tab completion, etc... might have to actually hijack the erlang shell to get those.
   - State "INPROGRESS" from "TODO"       [2017-08-09 Wed 21:08]
   An elixir shell that just waits for input and runs terp eval on it?
** DONE [#A] module system
   CLOSED: [2017-08-05 Sat 14:09]
   - State "DONE"       from "INPROGRESS" [2017-08-05 Sat 14:09] \\
     Export with =provide=, import with =require=.
   - State "INPROGRESS" from "TODO"       [2017-08-04 Fri 10:22]
*** Example syntax:
    =module= followed by the module's name and a list of the functions it exports:
    #+BEGIN_SRC scheme
      (module Prelude.List
              '(length
               reverse
               ...])
    #+END_SRC

    To import:
    #+BEGIN_SRC scheme
      (import Prelude.List) ;; import all functions from the module

      (import Prelude.List
              '(length))    ;; import just a given function
    #+END_SRC
    <2017-08-04 Fri 16:45> Scrapping the above idea and going with something more akin to Racket's module system.
    <2017-08-05 Sat 14:05> Gave up yesterday on figuring out how to only export certain functions without having to worry about what might happen if only the exported function was imported but it depended on something that wasn't exported.
    Decided to just import everything and have nothing be private. This morning, realized I could load everything, then unbind the hidden functions by updating the environment.
** DONE recursive functions
   CLOSED: [2017-08-02 Wed 18:26]
   =letrec= to define a recursive function
   This was a huge headache to actually get working, but so exciting when it did finally work.

   My naive attempt was to set up a dummy environment record for the function name so that the name wouldn't be unbound in the function body.
   This didn't end up working very well.

   Opted instead to pull out the free variable (e.g. function's name) from the function body, wrap the definition in an anonymous function, and use the Y-combinator to get the function's fixpoint.
   Then set the fixpoint function to the name in the environment.
** DONE add strings
   CLOSED: [2017-08-03 Thu 21:10]
   Strings are now valid.
